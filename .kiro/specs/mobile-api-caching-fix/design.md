# Design Document: Mobile API Caching Fix

## Overview

This design document outlines the technical approach to fix a critical security bug where API responses are being cached on mobile browsers, causing cross-user data leakage. The fix involves changes to the service worker, backend API headers, nginx configuration, and frontend logout behavior.

The root cause is a combination of aggressive mobile browser caching, service worker caching of API responses, and missing cache-control headers. The fix must ensure that authenticated API responses are never cached at any layer.

## Architecture

### Affected Components

1. **Service Worker** (`web-frontend/public/service-worker.js` or generated by Vite)
2. **Backend API** (Express middleware for cache headers)
3. **nginx Configuration** (reverse proxy cache settings)
4. **Frontend Auth Service** (logout behavior)
5. **API Client** (fetch configuration)

### Caching Layers

```
Mobile Browser
    ↓
Service Worker (Layer 1 - MUST NOT CACHE APIs)
    ↓
nginx Reverse Proxy (Layer 2 - MUST NOT CACHE APIs)
    ↓
Backend API (Layer 3 - MUST SET NO-CACHE HEADERS)
```

## Design Decisions

### Decision 1: Service Worker API Exclusion Strategy

**Approach:** Explicitly exclude all `/api/**` routes from service worker caching using a `NetworkOnly` strategy.

**Rationale:**
- Service workers have the highest priority in the request chain
- Even with correct HTTP headers, service workers can override caching behavior
- Mobile browsers rely heavily on service workers for offline functionality
- Explicit exclusion is more reliable than relying on cache headers

**Implementation:**
```javascript
// service-worker.js
import { NetworkOnly } from 'workbox-strategies';
import { registerRoute } from 'workbox-routing';

// Exclude all API routes from caching
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkOnly()
);

// Alternative: Manual fetch event listener
self.addEventListener('fetch', (event) => {
  // Skip caching for API requests
  if (event.request.url.includes('/api/')) {
    return; // Let the request pass through without caching
  }
  
  // Handle other requests with caching strategies
  // ...
});
```

**Verification:**
- Use Chrome DevTools → Application → Service Workers → Cache Storage
- Confirm no `/api/**` entries exist in cache
- Test on mobile Safari and Chrome

### Decision 2: Backend Cache Header Middleware

**Approach:** Create Express middleware that adds comprehensive no-cache headers to all authenticated API responses.

**Rationale:**
- Centralized header management ensures consistency
- Middleware can be applied globally to all API routes
- Headers must be present on all status codes (200, 304, 401, etc.)
- `Vary` header is critical for preventing cross-user cache reuse

**Implementation:**
```typescript
// backend-api/src/middleware/no-cache.middleware.ts
import { Request, Response, NextFunction } from 'express';

export function noCacheMiddleware(req: Request, res: Response, next: NextFunction) {
  // Set comprehensive no-cache headers
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
  res.setHeader('Pragma', 'no-cache'); // HTTP/1.0 compatibility
  res.setHeader('Expires', '0');
  
  // Critical: Vary header ensures separate caches per auth context
  res.setHeader('Vary', 'Authorization, Cookie');
  
  next();
}

// Apply to all API routes
app.use('/api', noCacheMiddleware);
```

**Header Breakdown:**
- `no-store`: Don't store response in any cache
- `no-cache`: Revalidate before using cached response
- `must-revalidate`: Force revalidation when stale
- `private`: Only browser can cache, not shared caches
- `Vary: Authorization, Cookie`: Separate cache per auth state

### Decision 3: nginx Proxy Cache Disabling

**Approach:** Explicitly disable nginx proxy caching for all API routes and add cache headers with `always` flag.

**Rationale:**
- nginx may cache responses even if backend doesn't
- `always` flag ensures headers are added to 304 responses
- Proxy cache bypass prevents nginx from serving stale responses
- Must be configured at the location block level

**Implementation:**
```nginx
# nginx.conf or site configuration
location /api/ {
    proxy_pass http://backend:3000;
    
    # Disable proxy caching
    proxy_no_cache 1;
    proxy_cache_bypass 1;
    
    # Add cache headers (always flag for 304 responses)
    add_header Cache-Control "no-store, no-cache, must-revalidate, private" always;
    add_header Pragma "no-cache" always;
    add_header Expires "0" always;
    
    # Disable ETag for API responses
    etag off;
    
    # Standard proxy headers
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}
```

**Verification:**
- Check response headers using `curl -I https://app.example.com/api/users/me`
- Confirm headers are present on 200, 304, and error responses
- Test with multiple requests to ensure no caching occurs

### Decision 4: ETag and Last-Modified Removal

**Approach:** Disable ETag and Last-Modified headers for authenticated API endpoints.

**Rationale:**
- Mobile browsers use conditional requests (If-None-Match, If-Modified-Since) to revalidate caches
- Even with no-cache headers, 304 responses can cause browsers to reuse stale data
- Removing these headers forces full 200 responses every time
- Trade-off: Slightly more bandwidth for guaranteed freshness

**Implementation:**

Backend (Express):
```typescript
// backend-api/src/middleware/no-cache.middleware.ts
export function noCacheMiddleware(req: Request, res: Response, next: NextFunction) {
  // ... existing headers ...
  
  // Remove ETag and Last-Modified headers
  res.removeHeader('ETag');
  res.removeHeader('Last-Modified');
  
  next();
}
```

nginx:
```nginx
location /api/ {
    # ... existing config ...
    etag off;
}
```

### Decision 5: Client-Side Fetch Configuration

**Approach:** Add `cache: 'no-store'` to all API fetch requests and implement diagnostic cache busting.

**Rationale:**
- Fetch API has its own caching behavior separate from HTTP headers
- `cache: 'no-store'` ensures browser doesn't use cached responses
- Cache busting with timestamps helps diagnose if caching is the issue
- Should be used in combination with proper headers, not as sole solution

**Implementation:**
```typescript
// web-frontend/src/services/api-client.ts
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '/api';
const ENABLE_CACHE_BUSTING = import.meta.env.VITE_ENABLE_CACHE_BUSTING === 'true';

export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  let url = `${API_BASE_URL}${endpoint}`;
  
  // Diagnostic cache busting (temporary)
  if (ENABLE_CACHE_BUSTING) {
    const separator = url.includes('?') ? '&' : '?';
    url = `${url}${separator}_t=${Date.now()}`;
    console.log('[Cache Buster] Request:', url);
  }
  
  const response = await fetch(url, {
    ...options,
    cache: 'no-store', // Never use cached responses
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });
  
  if (!response.ok) {
    throw new Error(`API request failed: ${response.statusText}`);
  }
  
  return response.json();
}
```

### Decision 6: Hard Logout with State Clearing

**Approach:** Perform a hard navigation to `/login` on logout, clearing all caches and state.

**Rationale:**
- Client-side routing preserves JavaScript state and caches
- Mobile browsers preserve state longer than desktop
- Hard navigation forces complete page reload
- React Query and other caches must be explicitly cleared
- `window.location.href` is more reliable than React Router navigation

**Implementation:**
```typescript
// web-frontend/src/services/auth.service.ts
export async function logout(): Promise<void> {
  try {
    // Call backend logout endpoint
    await fetch('/api/auth/logout', {
      method: 'POST',
      credentials: 'include',
    });
  } catch (error) {
    console.error('Logout API call failed:', error);
  }
  
  // Clear all client-side state
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('user');
  sessionStorage.clear();
  
  // Clear React Query cache
  queryClient.clear();
  
  // Hard navigation to force page reload
  // This clears all JavaScript state and caches
  window.location.href = '/login';
}
```

**Why Hard Navigation:**
- Clears all JavaScript heap memory
- Resets React component state
- Clears React Query cache completely
- Forces service worker to re-evaluate
- More reliable on mobile browsers

### Decision 7: Service Worker Debugging Tools

**Approach:** Create a debug page to inspect and control service worker behavior.

**Rationale:**
- Developers need visibility into service worker caching
- Ability to unregister service worker helps with testing
- Cache inspection helps verify API exclusion
- Useful for troubleshooting mobile-specific issues

**Implementation:**
```typescript
// web-frontend/src/pages/ServiceWorkerDebug.tsx
import React, { useState, useEffect } from 'react';
import { Container, Header, Button, SpaceBetween, Box } from '@cloudscape-design/components';

export function ServiceWorkerDebugPage() {
  const [registration, setRegistration] = useState<ServiceWorkerRegistration | null>(null);
  const [caches, setCaches] = useState<string[]>([]);
  
  useEffect(() => {
    loadServiceWorkerInfo();
  }, []);
  
  async function loadServiceWorkerInfo() {
    // Get service worker registration
    const reg = await navigator.serviceWorker.getRegistration();
    setRegistration(reg || null);
    
    // List all caches
    const cacheNames = await window.caches.keys();
    setCaches(cacheNames);
  }
  
  async function unregisterServiceWorker() {
    if (registration) {
      await registration.unregister();
      alert('Service worker unregistered. Reload the page.');
      setRegistration(null);
    }
  }
  
  async function clearAllCaches() {
    const cacheNames = await window.caches.keys();
    await Promise.all(cacheNames.map(name => window.caches.delete(name)));
    alert('All caches cleared.');
    setCaches([]);
  }
  
  async function inspectCache(cacheName: string) {
    const cache = await window.caches.open(cacheName);
    const requests = await cache.keys();
    const urls = requests.map(req => req.url);
    
    const apiUrls = urls.filter(url => url.includes('/api/'));
    if (apiUrls.length > 0) {
      alert(`⚠️ WARNING: API URLs found in cache!\n\n${apiUrls.join('\n')}`);
    } else {
      alert(`✓ No API URLs in cache "${cacheName}"`);
    }
  }
  
  return (
    <Container header={<Header variant="h1">Service Worker Debug</Header>}>
      <SpaceBetween size="l">
        <Box>
          <strong>Status:</strong> {registration ? 'Registered' : 'Not Registered'}
        </Box>
        
        {registration && (
          <Button onClick={unregisterServiceWorker}>
            Unregister Service Worker
          </Button>
        )}
        
        <Box>
          <strong>Caches:</strong> {caches.length}
        </Box>
        
        {caches.map(cacheName => (
          <Box key={cacheName}>
            {cacheName}
            <Button onClick={() => inspectCache(cacheName)}>
              Inspect
            </Button>
          </Box>
        ))}
        
        <Button onClick={clearAllCaches}>Clear All Caches</Button>
      </SpaceBetween>
    </Container>
  );
}
```

## Testing Strategy

### Unit Tests

1. **Service Worker Tests**
   - Verify API routes are excluded from caching
   - Verify NetworkOnly strategy is applied
   - Verify cache storage is empty for API routes

2. **Middleware Tests**
   - Verify cache headers are added to responses
   - Verify headers are present on all status codes
   - Verify Vary header includes Authorization and Cookie

3. **Logout Tests**
   - Verify localStorage is cleared
   - Verify React Query cache is cleared
   - Verify hard navigation occurs

### Integration Tests

1. **Cross-User Data Leakage Test**
   - User A logs in and views data
   - User A logs out
   - User B logs in
   - Verify User B sees only their data

2. **Mobile Browser Tests**
   - Test on mobile Safari (iOS)
   - Test on mobile Chrome (Android)
   - Test on mobile Chrome (iOS)
   - Verify no cached responses after logout

3. **Cache Header Tests**
   - Verify headers using curl or browser DevTools
   - Test 200, 304, 401, 403, 404, 500 responses
   - Verify headers are present on all responses

### Manual Testing Checklist

- [ ] Service worker does NOT cache `/api/**`
- [ ] API responses include `Cache-Control: no-store, no-cache, must-revalidate, private`
- [ ] API responses include `Vary: Authorization, Cookie`
- [ ] nginx caching disabled for APIs
- [ ] ETag / Last-Modified disabled for APIs
- [ ] Client state cleared on logout
- [ ] Hard navigation occurs on logout
- [ ] No cross-user data leakage on mobile Safari
- [ ] No cross-user data leakage on mobile Chrome (Android)
- [ ] No cross-user data leakage on mobile Chrome (iOS)

## Rollout Plan

### Phase 1: Backend and nginx (Immediate)
1. Deploy backend cache header middleware
2. Update nginx configuration
3. Verify headers in production

### Phase 2: Service Worker (Immediate)
1. Update service worker to exclude API routes
2. Deploy updated service worker
3. Verify cache storage is empty for APIs

### Phase 3: Frontend Logout (Immediate)
1. Update logout to use hard navigation
2. Clear all caches on logout
3. Test on mobile browsers

### Phase 4: Validation (Within 24 hours)
1. Complete manual testing checklist
2. Perform cross-user data leakage tests
3. Monitor for any reports of stale data

## Monitoring and Validation

### Metrics to Track
- Number of 304 responses (should decrease)
- Number of cache-related support tickets (should decrease to zero)
- API response times (may increase slightly due to no caching)

### Validation Commands

Check response headers:
```bash
curl -I https://app.example.com/api/users/me \
  -H "Authorization: Bearer <token>"
```

Expected output:
```
HTTP/2 200
cache-control: no-store, no-cache, must-revalidate, private
pragma: no-cache
expires: 0
vary: Authorization, Cookie
```

## Risks and Mitigations

### Risk 1: Performance Impact
**Mitigation:** Accept slight performance decrease for correctness. Monitor response times and optimize backend if needed.

### Risk 2: Service Worker Breaking Offline Functionality
**Mitigation:** Carefully test offline functionality after service worker changes. Ensure static assets are still cached.

### Risk 3: nginx Configuration Errors
**Mitigation:** Test nginx configuration in staging before production. Have rollback plan ready.

## Success Criteria

The fix is successful when:
1. Zero reports of cross-user data leakage
2. All validation checklist items pass
3. Mobile browser testing confirms fresh data after login
4. Service worker cache storage contains no API entries
5. All API responses include correct cache headers

## Correctness Properties

### Property 1: Service Worker API Exclusion
**Statement:** For all requests to `/api/**`, the service worker SHALL NOT cache the response.

**Validation:** Inspect service worker cache storage and verify no `/api/**` entries exist.

### Property 2: Cache Header Presence
**Statement:** For all authenticated API responses, the response SHALL include `Cache-Control: no-store, no-cache, must-revalidate, private` and `Vary: Authorization, Cookie` headers.

**Validation:** Make API requests and inspect response headers.

### Property 3: Cross-User Isolation
**Statement:** For any two users A and B, after A logs out and B logs in, B SHALL NOT see any data from A's session.

**Validation:** Perform cross-user login test on mobile browsers.

### Property 4: Logout State Clearing
**Statement:** When a user logs out, all client-side caches and state SHALL be cleared, and a hard navigation SHALL occur.

**Validation:** Inspect localStorage, sessionStorage, and React Query cache after logout.

### Property 5: nginx Cache Bypass
**Statement:** For all requests to `/api/**`, nginx SHALL NOT serve cached responses.

**Validation:** Make multiple identical API requests and verify backend is hit each time.

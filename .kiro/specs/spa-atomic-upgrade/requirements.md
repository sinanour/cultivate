# Requirements Document

## Introduction

This document specifies the requirements for implementing a production-grade atomic version upgrade system for a React 18 Single Page Application (SPA) using Vite, TypeScript, and Service Workers with Workbox. The system guarantees that no client ever runs a partially stale bundle, eliminates runtime 404 failures from deleted hashed chunks, and ensures safe multi-tab operation without infinite reload loops.

## Glossary

- **Service_Worker**: A JavaScript worker script that runs in the background, separate from web pages, enabling features like offline support and resource caching
- **Workbox**: A set of libraries and build tools from Google that simplify common service worker routing and caching patterns
- **Precaching**: The process of downloading and storing resources during service worker installation, before they are requested
- **Atomic_Upgrade**: A deployment strategy where all assets transition to a new version simultaneously, preventing mixed-version states
- **Hashed_Asset**: A file with a content-based hash in its filename (e.g., main.abc123.js) that changes when content changes
- **skipWaiting**: A service worker API that forces a waiting service worker to become active immediately
- **clientsClaim**: A service worker API that causes an active service worker to take control of all clients immediately
- **Chunk**: A JavaScript module file generated by the build process, typically loaded lazily on demand
- **Session_Storage**: Browser storage that persists data for the duration of a page session (until tab is closed)
- **Reload_Guard**: A mechanism using session storage to prevent infinite reload loops by tracking whether a reload has already occurred
- **Cache_Manifest**: A list of URLs and their revision identifiers used by Workbox to manage precached resources
- **Client**: A browser tab or window that is controlled by a service worker
- **Activation**: The phase when a service worker becomes active and takes control of clients

## Requirements

### Requirement 1: Service Worker Immediate Activation

**User Story:** As a system administrator, I want the service worker to activate immediately upon installation, so that new deployments take effect without waiting for all tabs to close.

#### Acceptance Criteria

1. WHEN a new service worker is installed, THE Service_Worker SHALL call skipWaiting() to activate immediately
2. WHEN the service worker activates, THE Service_Worker SHALL call clientsClaim() to take control of all clients immediately
3. THE Service_Worker SHALL use Workbox libraries for precaching and core functionality

### Requirement 2: Build Manifest Precaching

**User Story:** As a developer, I want all build assets to be precached during service worker installation, so that the application has a complete set of versioned resources.

#### Acceptance Criteria

1. WHEN the service worker installs, THE Service_Worker SHALL precache all assets listed in the Workbox manifest using precacheAndRoute()
2. THE Build_System SHALL generate a Workbox manifest containing all hashed build assets
3. WHEN a new deployment occurs, THE Service_Worker SHALL receive an updated manifest with new file hashes
4. THE Service_Worker SHALL use content hashes for automatic versioning of precached assets

### Requirement 3: Old Cache Deletion

**User Story:** As a system administrator, I want old caches to be deleted during service worker activation, so that no stale assets remain after deployment.

#### Acceptance Criteria

1. WHEN the service worker activates, THE Service_Worker SHALL retrieve all existing cache keys
2. WHEN processing cache keys, THE Service_Worker SHALL preserve only Workbox precache and runtime caches
3. WHEN processing cache keys, THE Service_Worker SHALL delete all other caches
4. THE Service_Worker SHALL complete cache deletion before taking control of clients

### Requirement 4: Upgrade Notification Broadcasting

**User Story:** As a user with multiple tabs open, I want all tabs to be notified when a new version is available, so that all instances upgrade consistently.

#### Acceptance Criteria

1. WHEN the service worker activates, THE Service_Worker SHALL retrieve all window clients
2. WHEN the service worker activates, THE Service_Worker SHALL post a message with type 'NEW_VERSION_READY' to each client
3. THE Service_Worker SHALL broadcast to all clients before completing activation

### Requirement 5: Client-Side Upgrade Handler

**User Story:** As a user, I want the application to reload automatically when a new version is available, so that I always run the latest code.

#### Acceptance Criteria

1. THE Upgrade_Handler SHALL listen for service worker 'message' events
2. THE Upgrade_Handler SHALL listen for service worker 'controllerchange' events
3. WHEN a message with type 'NEW_VERSION_READY' is received, THE Upgrade_Handler SHALL check the reload guard
4. WHEN the reload guard is not set, THE Upgrade_Handler SHALL set the reload guard in session storage
5. WHEN the reload guard is set, THE Upgrade_Handler SHALL trigger window.location.reload()
6. THE Upgrade_Handler SHALL be initialized before React renders

### Requirement 6: Reload Guard Implementation

**User Story:** As a developer, I want to prevent infinite reload loops, so that deployment issues don't cause the application to become unusable.

#### Acceptance Criteria

1. THE Reload_Guard SHALL use a session storage key 'app-version-reload'
2. WHEN checking the reload guard, THE Reload_Guard SHALL return true if the key exists in session storage
3. WHEN setting the reload guard, THE Reload_Guard SHALL store the key in session storage
4. WHEN a tab is closed, THE Browser SHALL clear the session storage automatically
5. THE Reload_Guard SHALL ensure exactly one reload per tab per deployment

### Requirement 7: Vite Build Configuration

**User Story:** As a developer, I want the build system to generate content-hashed filenames, so that assets can be safely cached long-term.

#### Acceptance Criteria

1. WHEN building for production, THE Build_System SHALL generate content-hashed filenames for all JavaScript entry files
2. WHEN building for production, THE Build_System SHALL generate content-hashed filenames for all JavaScript chunks
3. WHEN building for production, THE Build_System SHALL generate content-hashed filenames for all CSS and asset files
4. THE Build_System SHALL use the format 'assets/[name].[hash].[ext]' for output files

### Requirement 8: HTTP Cache Headers

**User Story:** As a system administrator, I want proper cache headers configured, so that HTML is always fresh and assets are safely long-lived.

#### Acceptance Criteria

1. WHEN serving index.html, THE Server SHALL set Cache-Control header to 'no-cache'
2. WHEN serving JavaScript assets, THE Server SHALL set Cache-Control header to 'public, max-age=31536000, immutable'
3. WHEN serving CSS assets, THE Server SHALL set Cache-Control header to 'public, max-age=31536000, immutable'
4. THE Server SHALL ensure HTML always references the newest hashed bundles

### Requirement 9: Legacy Chunk Retry Removal

**User Story:** As a developer, I want to remove legacy chunk retry logic, so that the codebase is simplified and relies on the atomic upgrade system.

#### Acceptance Criteria

1. THE Codebase SHALL NOT contain lazyWithRetry wrapper functions
2. THE Codebase SHALL NOT contain dynamic import retry handlers
3. THE Codebase SHALL NOT contain global unhandledrejection reload logic
4. THE Codebase SHALL rely solely on the service worker upgrade system for handling stale chunks

### Requirement 10: Multi-Tab Safety

**User Story:** As a user with multiple tabs open, I want all tabs to upgrade safely without race conditions, so that my workflow is not disrupted.

#### Acceptance Criteria

1. WHEN multiple tabs are open, THE Service_Worker SHALL broadcast upgrade notifications to all tabs
2. WHEN an upgrade notification is received, THE Upgrade_Handler SHALL reload each tab exactly once
3. WHEN tabs reload, THE System SHALL prevent race conditions between tabs
4. THE System SHALL ensure all tabs transition to the new version atomically

### Requirement 11: Workbox Integration

**User Story:** As a developer, I want to use Workbox for service worker functionality, so that I leverage battle-tested caching strategies.

#### Acceptance Criteria

1. THE Project SHALL include workbox-core as a dependency
2. THE Project SHALL include workbox-precaching as a dependency
3. THE Project SHALL include a Vite plugin for Workbox integration
4. THE Build_System SHALL generate the Workbox manifest during production builds
5. THE Service_Worker SHALL import and use Workbox APIs for precaching and cache management

### Requirement 12: Service Worker Registration

**User Story:** As a developer, I want the service worker to be registered on application startup, so that upgrade handling is active from the first page load.

#### Acceptance Criteria

1. WHEN the application starts, THE Application SHALL check if service workers are supported
2. WHEN service workers are supported, THE Application SHALL register the service worker
3. WHEN registration succeeds, THE Application SHALL initialize the upgrade handler
4. THE Application SHALL register the service worker before rendering React components

### Requirement 13: Atomic Deployment Guarantees

**User Story:** As a system administrator, I want atomic deployment guarantees, so that clients never run mixed-version bundles.

#### Acceptance Criteria

1. WHEN a deployment occurs, THE System SHALL ensure no client runs a partially stale bundle
2. WHEN a deployment occurs, THE System SHALL ensure deleted hashed chunks never cause runtime 404 failures
3. WHEN a deployment occurs, THE System SHALL activate the new version immediately
4. WHEN a deployment occurs, THE System SHALL reload each page exactly once per tab
5. THE System SHALL make infinite reload loops impossible through the reload guard
6. THE System SHALL allow old assets to be deleted server-side immediately after deployment

### Requirement 14: Offline/Online Transition Handling

**User Story:** As a user, I want the application to handle offline/online transitions gracefully, so that upgrades work correctly even with intermittent connectivity.

#### Acceptance Criteria

1. WHEN the application goes offline, THE Service_Worker SHALL serve precached assets
2. WHEN the application comes back online, THE Service_Worker SHALL check for updates
3. WHEN an update is available after coming online, THE System SHALL trigger the upgrade flow
4. THE System SHALL handle offline/online transitions without data loss or corruption

### Requirement 15: TypeScript Type Safety

**User Story:** As a developer, I want TypeScript types for all service worker code, so that I catch errors at compile time.

#### Acceptance Criteria

1. THE Service_Worker SHALL be written in TypeScript
2. THE Upgrade_Handler SHALL be written in TypeScript
3. THE Service_Worker SHALL have proper type definitions for Workbox APIs
4. THE Service_Worker SHALL have proper type definitions for service worker global scope
5. THE Build_System SHALL compile TypeScript service worker code to JavaScript

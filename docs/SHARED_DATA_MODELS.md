# Shared Data Models: Community Activity Tracker

## Overview

This document defines the canonical data models used across all packages in the Community Activity Tracker system. All packages (Backend API, Web Frontend, iOS Mobile App, Android Mobile App) must implement equivalent representations of these models to ensure data consistency.

**Version**: 1.0.0

## Core Principles

1. **Single Source of Truth**: Backend database is authoritative
2. **Type Safety**: All fields have explicit types
3. **Consistency**: Field names and types match across all platforms
4. **Validation**: All models include validation rules
5. **Versioning**: Entities include version numbers for optimistic locking

## Data Model Conventions

### Identifiers
- All entity IDs are UUIDs (RFC 4122)
- Format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
- Generated by backend on creation

### Timestamps
- All timestamps use ISO 8601 format with UTC timezone
- Format: `YYYY-MM-DDTHH:mm:ss.sssZ`
- Example: `2024-01-15T14:30:00.000Z`

### Nullable Fields
- Fields marked as `| null` can be null
- Fields without `| null` are required

### Enums
- Enums use string values for readability
- Values are case-sensitive

## User and Authentication

### User

Represents a system user with authentication credentials.

**TypeScript**:
```typescript
interface User {
  id: string;              // UUID
  email: string;           // Unique, validated email
  passwordHash: string;    // bcrypt hash (backend only, never sent to clients)
  name: string;            // Display name
  systemRole: SystemRole;  // User's system-wide role
  createdAt: Date;         // Account creation timestamp
  updatedAt: Date;         // Last update timestamp
}
```

**Swift**:
```swift
struct User: Codable, Identifiable {
    let id: UUID
    let email: String
    let name: String
    let systemRole: SystemRole
    let createdAt: Date
    let updatedAt: Date
}
```

**Kotlin**:
```kotlin
data class User(
    val id: UUID,
    val email: String,
    val name: String,
    val systemRole: SystemRole,
    val createdAt: Instant,
    val updatedAt: Instant
)
```

**Validation Rules**:
- `email`: Valid email format, max 255 characters
- `name`: 1-255 characters
- `passwordHash`: Backend only, bcrypt with cost factor 12

### SystemRole

User's system-wide permission level.

**TypeScript**:
```typescript
enum SystemRole {
  Administrator = "Administrator",
  Editor = "Editor",
  ReadOnly = "ReadOnly"
}
```

**Swift**:
```swift
enum SystemRole: String, Codable {
    case administrator = "Administrator"
    case editor = "Editor"
    case readOnly = "ReadOnly"
}
```

**Kotlin**:
```kotlin
enum class SystemRole {
    ADMINISTRATOR,
    EDITOR,
    READ_ONLY;
    
    companion object {
        fun fromString(value: String): SystemRole = when(value) {
            "Administrator" -> ADMINISTRATOR
            "Editor" -> EDITOR
            "ReadOnly" -> READ_ONLY
            else -> throw IllegalArgumentException("Unknown role: $value")
        }
    }
}
```

**Permissions**:
- `Administrator`: Full access (create, read, update, delete)
- `Editor`: Create, read, update (no delete)
- `ReadOnly`: Read only

## Activity Management

### Activity

Represents a community activity or event.

**TypeScript**:
```typescript
interface Activity {
  id: string;              // UUID
  name: string;            // Activity name
  description: string;     // Detailed description
  activityType: ActivityType;
  status: ActivityStatus;
  startDate: Date;         // Activity start date
  endDate: Date | null;    // Activity end date (null for ongoing)
  isOngoing: boolean;      // True if activity has no end date
  venues: ActivityVenueHistory[];  // Venue associations over time
  createdBy: string;       // User ID who created the activity
  createdAt: Date;         // Creation timestamp
  updatedAt: Date;         // Last update timestamp
  version: number;         // Version for optimistic locking
}
```

**Swift**:
```swift
struct Activity: Codable, Identifiable {
    let id: UUID
    var name: String
    var description: String
    var activityType: ActivityType
    var status: ActivityStatus
    var startDate: Date
    var endDate: Date?
    var isOngoing: Bool
    var venues: [ActivityVenueHistory]
    let createdBy: UUID
    let createdAt: Date
    var updatedAt: Date
    var version: Int
}
```

**Kotlin**:
```kotlin
data class Activity(
    val id: UUID,
    var name: String,
    var description: String,
    var activityType: ActivityType,
    var status: ActivityStatus,
    var startDate: LocalDate,
    var endDate: LocalDate?,
    var isOngoing: Boolean,
    var venues: List<ActivityVenueHistory>,
    val createdBy: UUID,
    val createdAt: Instant,
    var updatedAt: Instant,
    var version: Int
)
```

**Validation Rules**:
- `name`: 1-255 characters, required
- `description`: 0-10000 characters
- `startDate`: Required, valid date
- `endDate`: Must be >= startDate if not null
- `isOngoing`: If true, endDate must be null
- `version`: Positive integer, incremented on each update

### ActivityType

Category of activity (predefined or custom).

**TypeScript**:
```typescript
interface ActivityType {
  id: string;              // UUID
  name: string;            // Type name
  isPredefined: boolean;   // True for system-defined types
  createdAt: Date;
}
```

**Swift**:
```swift
struct ActivityType: Codable, Identifiable {
    let id: UUID
    let name: String
    let isPredefined: Bool
    let createdAt: Date
}
```

**Kotlin**:
```kotlin
data class ActivityType(
    val id: UUID,
    val name: String,
    val isPredefined: Boolean,
    val createdAt: Instant
)
```

**Predefined Types**:
- Workshop
- Meetup
- Class
- Conference
- Social Event
- Training
- Volunteer Activity

**Validation Rules**:
- `name`: 1-100 characters, unique
- `isPredefined`: Cannot be modified after creation

### ActivityStatus

Current state of an activity.

**TypeScript**:
```typescript
enum ActivityStatus {
  Planning = "Planning",
  Active = "Active",
  Completed = "Completed",
  Archived = "Archived"
}
```

**Swift**:
```swift
enum ActivityStatus: String, Codable {
    case planning = "Planning"
    case active = "Active"
    case completed = "Completed"
    case archived = "Archived"
}
```

**Kotlin**:
```kotlin
enum class ActivityStatus {
    PLANNING,
    ACTIVE,
    COMPLETED,
    ARCHIVED;
    
    companion object {
        fun fromString(value: String): ActivityStatus = when(value) {
            "Planning" -> PLANNING
            "Active" -> ACTIVE
            "Completed" -> COMPLETED
            "Archived" -> ARCHIVED
            else -> throw IllegalArgumentException("Unknown status: $value")
        }
    }
}
```

**Status Transitions**:
- Planning → Active
- Active → Completed
- Completed → Archived
- Any status → Planning (reset)

### ActivityVenueHistory

Tracks venue associations for activities over time (Type 2 SCD).

**TypeScript**:
```typescript
interface ActivityVenueHistory {
  id: string;              // UUID
  activityId: string;      // UUID
  venueId: string;         // UUID
  venue: Venue;            // Denormalized venue data
  effectiveFrom: Date;     // Start of association
  effectiveTo: Date | null; // End of association (null = current)
}
```

**Swift**:
```swift
struct ActivityVenueHistory: Codable, Identifiable {
    let id: UUID
    let activityId: UUID
    let venueId: UUID
    let venue: Venue
    let effectiveFrom: Date
    let effectiveTo: Date?
}
```

**Kotlin**:
```kotlin
data class ActivityVenueHistory(
    val id: UUID,
    val activityId: UUID,
    val venueId: UUID,
    val venue: Venue,
    val effectiveFrom: Instant,
    val effectiveTo: Instant?
)
```

**Validation Rules**:
- `effectiveFrom`: Required, valid timestamp
- `effectiveTo`: Must be > effectiveFrom if not null
- Only one record per activity can have null effectiveTo (current venue)

## Participant Management

### Participant

Represents an individual who participates in activities.

**TypeScript**:
```typescript
interface Participant {
  id: string;              // UUID
  name: string;            // Participant name
  email: string | null;    // Optional email
  phone: string | null;    // Optional phone
  notes: string;           // Additional notes
  homeVenueId: string | null; // Current home venue
  createdAt: Date;
  updatedAt: Date;
  version: number;
}
```

**Swift**:
```swift
struct Participant: Codable, Identifiable {
    let id: UUID
    var name: String
    var email: String?
    var phone: String?
    var notes: String
    var homeVenueId: UUID?
    let createdAt: Date
    var updatedAt: Date
    var version: Int
}
```

**Kotlin**:
```kotlin
data class Participant(
    val id: UUID,
    var name: String,
    var email: String?,
    var phone: String?,
    var notes: String,
    var homeVenueId: UUID?,
    val createdAt: Instant,
    var updatedAt: Instant,
    var version: Int
)
```

**Validation Rules**:
- `name`: 1-255 characters, required
- `email`: Valid email format if provided, max 255 characters
- `phone`: Max 50 characters
- `notes`: Max 10000 characters

### ParticipantRole

Role a participant plays in an activity.

**TypeScript**:
```typescript
interface ParticipantRole {
  id: string;              // UUID
  name: string;            // Role name
  isPredefined: boolean;   // True for system-defined roles
  createdAt: Date;
}
```

**Swift**:
```swift
struct ParticipantRole: Codable, Identifiable {
    let id: UUID
    let name: String
    let isPredefined: Bool
    let createdAt: Date
}
```

**Kotlin**:
```kotlin
data class ParticipantRole(
    val id: UUID,
    val name: String,
    val isPredefined: Boolean,
    val createdAt: Instant
)
```

**Predefined Roles**:
- Facilitator
- Animator
- Host
- Teacher
- Participant
- Volunteer
- Organizer

### ActivityParticipant

Join table linking activities and participants with roles.

**TypeScript**:
```typescript
interface ActivityParticipant {
  id: string;              // UUID
  activityId: string;      // UUID
  participantId: string;   // UUID
  participant: Participant; // Denormalized participant data
  role: ParticipantRole;   // Participant's role in this activity
  joinedAt: Date;          // When participant joined
  notes: string;           // Activity-specific notes
}
```

**Swift**:
```swift
struct ActivityParticipant: Codable, Identifiable {
    let id: UUID
    let activityId: UUID
    let participantId: UUID
    let participant: Participant
    let role: ParticipantRole
    let joinedAt: Date
    var notes: String
}
```

**Kotlin**:
```kotlin
data class ActivityParticipant(
    val id: UUID,
    val activityId: UUID,
    val participantId: UUID,
    val participant: Participant,
    val role: ParticipantRole,
    val joinedAt: Instant,
    var notes: String
)
```

**Validation Rules**:
- Unique constraint on (activityId, participantId)
- `notes`: Max 10000 characters

### ParticipantAddressHistory

Tracks participant home address changes over time (Type 2 SCD).

**TypeScript**:
```typescript
interface ParticipantAddressHistory {
  id: string;              // UUID
  participantId: string;   // UUID
  venueId: string;         // UUID (venue represents the address)
  venue: Venue;            // Denormalized venue data
  effectiveFrom: Date;     // Start of address validity
  effectiveTo: Date | null; // End of address validity (null = current)
}
```

**Swift**:
```swift
struct ParticipantAddressHistory: Codable, Identifiable {
    let id: UUID
    let participantId: UUID
    let venueId: UUID
    let venue: Venue
    let effectiveFrom: Date
    let effectiveTo: Date?
}
```

**Kotlin**:
```kotlin
data class ParticipantAddressHistory(
    val id: UUID,
    val participantId: UUID,
    val venueId: UUID,
    val venue: Venue,
    val effectiveFrom: Instant,
    val effectiveTo: Instant?
)
```

**Validation Rules**:
- `effectiveFrom`: Required, valid timestamp
- `effectiveTo`: Must be > effectiveFrom if not null
- Only one record per participant can have null effectiveTo (current address)
- Date ranges for same participant must not overlap

## Geographic Management

### Venue

Physical location where activities occur or participants reside.

**TypeScript**:
```typescript
interface Venue {
  id: string;              // UUID
  name: string;            // Venue name
  address: string;         // Full address
  geographicAreaId: string; // UUID
  geographicArea: GeographicArea; // Denormalized area data
  latitude: number | null; // GPS latitude
  longitude: number | null; // GPS longitude
  venueType: VenueType | null; // Type of venue
  createdAt: Date;
  updatedAt: Date;
}
```

**Swift**:
```swift
struct Venue: Codable, Identifiable {
    let id: UUID
    var name: String
    var address: String
    var geographicAreaId: UUID
    var geographicArea: GeographicArea
    var latitude: Double?
    var longitude: Double?
    var venueType: VenueType?
    let createdAt: Date
    var updatedAt: Date
}
```

**Kotlin**:
```kotlin
data class Venue(
    val id: UUID,
    var name: String,
    var address: String,
    var geographicAreaId: UUID,
    var geographicArea: GeographicArea,
    var latitude: Double?,
    var longitude: Double?,
    var venueType: VenueType?,
    val createdAt: Instant,
    var updatedAt: Instant
)
```

**Validation Rules**:
- `name`: 1-255 characters, required
- `address`: 1-500 characters, required
- `geographicAreaId`: Must reference existing geographic area
- `latitude`: -90 to 90 if provided
- `longitude`: -180 to 180 if provided

### VenueType

Type of venue.

**TypeScript**:
```typescript
enum VenueType {
  PublicBuilding = "PUBLIC_BUILDING",
  PrivateResidence = "PRIVATE_RESIDENCE"
}
```

**Swift**:
```swift
enum VenueType: String, Codable {
    case publicBuilding = "PUBLIC_BUILDING"
    case privateResidence = "PRIVATE_RESIDENCE"
}
```

**Kotlin**:
```kotlin
enum class VenueType {
    PUBLIC_BUILDING,
    PRIVATE_RESIDENCE;
    
    companion object {
        fun fromString(value: String): VenueType = when(value) {
            "PUBLIC_BUILDING" -> PUBLIC_BUILDING
            "PRIVATE_RESIDENCE" -> PRIVATE_RESIDENCE
            else -> throw IllegalArgumentException("Unknown venue type: $value")
        }
    }
}
```

### GeographicArea

Hierarchical geographic region for organizing venues.

**TypeScript**:
```typescript
interface GeographicArea {
  id: string;              // UUID
  name: string;            // Area name
  areaType: GeographicAreaType;
  parentGeographicAreaId: string | null; // UUID of parent area
  parent: GeographicArea | null; // Denormalized parent data
  children: GeographicArea[]; // Child areas (not always loaded)
  createdAt: Date;
  updatedAt: Date;
}
```

**Swift**:
```swift
struct GeographicArea: Codable, Identifiable {
    let id: UUID
    var name: String
    var areaType: GeographicAreaType
    var parentGeographicAreaId: UUID?
    var parent: GeographicArea?
    var children: [GeographicArea]
    let createdAt: Date
    var updatedAt: Date
}
```

**Kotlin**:
```kotlin
data class GeographicArea(
    val id: UUID,
    var name: String,
    var areaType: GeographicAreaType,
    var parentGeographicAreaId: UUID?,
    var parent: GeographicArea?,
    var children: List<GeographicArea>,
    val createdAt: Instant,
    var updatedAt: Instant
)
```

**Validation Rules**:
- `name`: 1-255 characters, required
- `parentGeographicAreaId`: Must reference existing area if provided
- Cannot create circular relationships (area cannot be its own ancestor)

### GeographicAreaType

Type of geographic area.

**TypeScript**:
```typescript
enum GeographicAreaType {
  Neighbourhood = "NEIGHBOURHOOD",
  Community = "COMMUNITY",
  City = "CITY",
  Cluster = "CLUSTER",
  County = "COUNTY",
  Province = "PROVINCE",
  State = "STATE",
  Country = "COUNTRY",
  Custom = "CUSTOM"
}
```

**Swift**:
```swift
enum GeographicAreaType: String, Codable {
    case neighbourhood = "NEIGHBOURHOOD"
    case community = "COMMUNITY"
    case city = "CITY"
    case cluster = "CLUSTER"
    case county = "COUNTY"
    case province = "PROVINCE"
    case state = "STATE"
    case country = "COUNTRY"
    case custom = "CUSTOM"
}
```

**Kotlin**:
```kotlin
enum class GeographicAreaType {
    NEIGHBOURHOOD,
    COMMUNITY,
    CITY,
    CLUSTER,
    COUNTY,
    PROVINCE,
    STATE,
    COUNTRY,
    CUSTOM;
    
    companion object {
        fun fromString(value: String): GeographicAreaType = valueOf(value)
    }
}
```

### GeographicAreaStatistics

Aggregated statistics for a geographic area.

**TypeScript**:
```typescript
interface GeographicAreaStatistics {
  geographicAreaId: string; // UUID
  totalActivities: number;
  totalParticipants: number;
  activeActivities: number;
  ongoingActivities: number;
}
```

**Swift**:
```swift
struct GeographicAreaStatistics: Codable {
    let geographicAreaId: UUID
    let totalActivities: Int
    let totalParticipants: Int
    let activeActivities: Int
    let ongoingActivities: Int
}
```

**Kotlin**:
```kotlin
data class GeographicAreaStatistics(
    val geographicAreaId: UUID,
    val totalActivities: Int,
    val totalParticipants: Int,
    val activeActivities: Int,
    val ongoingActivities: Int
)
```

## Analytics

### EngagementMetrics

Engagement metrics for a time period.

**TypeScript**:
```typescript
interface EngagementMetrics {
  totalActivities: number;
  activeActivities: number;
  totalParticipants: number;
  activeParticipants: number;
  participationRate: number;    // Percentage (0-100)
  retentionRate: number;        // Percentage (0-100)
  averageActivitySize: number;  // Average participants per activity
  geographicBreakdown: GeographicEngagement[];
  periodStart: Date;
  periodEnd: Date;
}
```

**Swift**:
```swift
struct EngagementMetrics: Codable {
    let totalActivities: Int
    let activeActivities: Int
    let totalParticipants: Int
    let activeParticipants: Int
    let participationRate: Double
    let retentionRate: Double
    let averageActivitySize: Double
    let geographicBreakdown: [GeographicEngagement]
    let periodStart: Date
    let periodEnd: Date
}
```

**Kotlin**:
```kotlin
data class EngagementMetrics(
    val totalActivities: Int,
    val activeActivities: Int,
    val totalParticipants: Int,
    val activeParticipants: Int,
    val participationRate: Double,
    val retentionRate: Double,
    val averageActivitySize: Double,
    val geographicBreakdown: List<GeographicEngagement>,
    val periodStart: Instant,
    val periodEnd: Instant
)
```

### GeographicEngagement

Engagement metrics broken down by geographic area.

**TypeScript**:
```typescript
interface GeographicEngagement {
  geographicAreaId: string;
  geographicAreaName: string;
  activityCount: number;
  participantCount: number;
}
```

**Swift**:
```swift
struct GeographicEngagement: Codable {
    let geographicAreaId: UUID
    let geographicAreaName: String
    let activityCount: Int
    let participantCount: Int
}
```

**Kotlin**:
```kotlin
data class GeographicEngagement(
    val geographicAreaId: UUID,
    val geographicAreaName: String,
    val activityCount: Int,
    val participantCount: Int
)
```

### GrowthData

Time-series growth data.

**TypeScript**:
```typescript
interface GrowthData {
  date: Date;
  newParticipants: number;
  newActivities: number;
  cumulativeParticipants: number;
  cumulativeActivities: number;
}
```

**Swift**:
```swift
struct GrowthData: Codable {
    let date: Date
    let newParticipants: Int
    let newActivities: Int
    let cumulativeParticipants: Int
    let cumulativeActivities: Int
}
```

**Kotlin**:
```kotlin
data class GrowthData(
    val date: LocalDate,
    val newParticipants: Int,
    val newActivities: Int,
    val cumulativeParticipants: Int,
    val cumulativeActivities: Int
)
```

## Synchronization

### SyncOperation

Represents a local change to be synchronized.

**TypeScript**:
```typescript
interface SyncOperation {
  id: string;              // UUID
  entityType: string;      // "Activity" | "Participant" | "ActivityParticipant" | "Venue" | "GeographicArea"
  entityId: string;        // UUID
  operation: string;       // "CREATE" | "UPDATE" | "DELETE"
  data: any;               // Entity data
  timestamp: Date;         // When operation was created
  clientId: string;        // Unique client identifier
  version: number;         // Entity version for conflict detection
}
```

**Swift**:
```swift
struct SyncOperation: Codable, Identifiable {
    let id: UUID
    let entityType: String
    let entityId: UUID
    let operation: String
    let data: Data  // JSON encoded entity
    let timestamp: Date
    let clientId: UUID
    let version: Int
}
```

**Kotlin**:
```kotlin
data class SyncOperation(
    val id: UUID,
    val entityType: String,
    val entityId: UUID,
    val operation: String,
    val data: JsonObject,
    val timestamp: Instant,
    val clientId: UUID,
    val version: Int
)
```

### SyncState

Current synchronization state for a client.

**TypeScript**:
```typescript
interface SyncState {
  clientId: string;        // UUID
  lastSyncTimestamp: Date;
  pendingOperations: number;
  conflictCount: number;
}
```

**Swift**:
```swift
struct SyncState: Codable {
    let clientId: UUID
    let lastSyncTimestamp: Date
    let pendingOperations: Int
    let conflictCount: Int
}
```

**Kotlin**:
```kotlin
data class SyncState(
    val clientId: UUID,
    val lastSyncTimestamp: Instant,
    val pendingOperations: Int,
    val conflictCount: Int
)
```

## Implementation Guidelines

### Backend API (TypeScript/Prisma)

```typescript
// Use Prisma schema to define models
// Generate TypeScript types from schema
// Export types for use in API and tests

import { Prisma } from '@prisma/client';

export type Activity = Prisma.ActivityGetPayload<{
  include: {
    activityType: true,
    venues: {
      include: {
        venue: true
      }
    }
  }
}>;
```

### Web Frontend (TypeScript/React)

```typescript
// Import types from generated API client
// Use Zod for runtime validation
// Store in IndexedDB for offline support

import { z } from 'zod';

const ActivitySchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(255),
  // ... other fields
});

type Activity = z.infer<typeof ActivitySchema>;
```

### iOS Mobile App (Swift/Core Data)

```swift
// Define Core Data entities matching models
// Use Codable for JSON serialization
// Implement custom init for API responses

extension Activity {
    init(from apiResponse: APIActivity) {
        self.id = apiResponse.id
        self.name = apiResponse.name
        // ... other fields
    }
}
```

### Android Mobile App (Kotlin/Room)

```kotlin
// Define Room entities matching models
// Use kotlinx.serialization for JSON
// Implement type converters for custom types

@Entity(tableName = "activities")
data class ActivityEntity(
    @PrimaryKey val id: UUID,
    val name: String,
    // ... other fields
) {
    fun toActivity(): Activity = Activity(
        id = id,
        name = name,
        // ... other fields
    )
}
```

## Version History

- **1.0.0** (2024-01-15): Initial data model definitions
  - Core entities: User, Activity, Participant
  - Geographic entities: Venue, GeographicArea
  - Analytics models
  - Synchronization models
  - Temporal tracking with Type 2 SCD

## Migration Notes

When updating data models:

1. Update this document first
2. Update backend Prisma schema
3. Create database migration
4. Update API types and validation
5. Update client type definitions
6. Update tests
7. Deploy backend first
8. Deploy clients with backward compatibility

## Validation Summary

| Entity | Required Fields | Unique Constraints | Foreign Keys |
|--------|----------------|-------------------|--------------|
| User | email, name, systemRole | email | - |
| Activity | name, activityTypeId, status, startDate | - | activityTypeId, createdBy |
| Participant | name | - | homeVenueId (optional) |
| Venue | name, address, geographicAreaId | - | geographicAreaId |
| GeographicArea | name, areaType | - | parentGeographicAreaId (optional) |
| ActivityParticipant | activityId, participantId, roleId | (activityId, participantId) | activityId, participantId, roleId |
| ActivityVenueHistory | activityId, venueId, effectiveFrom | - | activityId, venueId |
| ParticipantAddressHistory | participantId, venueId, effectiveFrom | - | participantId, venueId |
